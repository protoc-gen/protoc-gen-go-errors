// Code generated by protoc-gen-go-errors. DO NOT EDIT.

package main

import (
	context "context"
	errors1 "errors"
	errors "github.com/protoc-gen/protoc-gen-go-errors/errors"
)

func As(err error) *errors.Error {
	if err == nil {
		return nil
	}
	var e *errors.Error
	if errors1.As(err, &e) {
		return e
	}
	return nil
}

func New(code int, reason, message string) *errors.Error {
	return errors.New(code, reason, message)
}

func IsBadRequest(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ClientError_BAD_REQUEST.String() && e.Code == 400
}

func ErrorBadRequest() *errors.Error {
	return errors.New(400, ClientError_BAD_REQUEST.String(), "")
}

func ErrorBadRequestWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(400, ClientError_BAD_REQUEST.String(), ctx, data)
}

func IsUserNotFound(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ClientError_USER_NOT_FOUND.String() && e.Code == 400
}

func ErrorUserNotFound() *errors.Error {
	return errors.New(400, ClientError_USER_NOT_FOUND.String(), "")
}

func ErrorUserNotFoundWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(400, ClientError_USER_NOT_FOUND.String(), ctx, data)
}

func IsUserAlreadyExists(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ClientError_USER_ALREADY_EXISTS.String() && e.Code == 400
}

func ErrorUserAlreadyExists() *errors.Error {
	return errors.New(400, ClientError_USER_ALREADY_EXISTS.String(), "")
}

func ErrorUserAlreadyExistsWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(400, ClientError_USER_ALREADY_EXISTS.String(), ctx, data)
}

func IsInvalidEmailOrPassword(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ClientError_INVALID_EMAIL_OR_PASSWORD.String() && e.Code == 400
}

func ErrorInvalidEmailOrPassword() *errors.Error {
	return errors.New(400, ClientError_INVALID_EMAIL_OR_PASSWORD.String(), "")
}

func ErrorInvalidEmailOrPasswordWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(400, ClientError_INVALID_EMAIL_OR_PASSWORD.String(), ctx, data)
}

func IsProviderNotSupported(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ClientError_PROVIDER_NOT_SUPPORTED.String() && e.Code == 400
}

func ErrorProviderNotSupported() *errors.Error {
	return errors.New(400, ClientError_PROVIDER_NOT_SUPPORTED.String(), "")
}

func ErrorProviderNotSupportedWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(400, ClientError_PROVIDER_NOT_SUPPORTED.String(), ctx, data)
}

func IsUnauthorized(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UnauthorizedError_UNAUTHORIZED.String() && e.Code == 401
}

func ErrorUnauthorized() *errors.Error {
	return errors.New(401, UnauthorizedError_UNAUTHORIZED.String(), "")
}

func ErrorUnauthorizedWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(401, UnauthorizedError_UNAUTHORIZED.String(), ctx, data)
}

func IsInvalidToken(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UnauthorizedError_INVALID_TOKEN.String() && e.Code == 401
}

func ErrorInvalidToken() *errors.Error {
	return errors.New(401, UnauthorizedError_INVALID_TOKEN.String(), "")
}

func ErrorInvalidTokenWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(401, UnauthorizedError_INVALID_TOKEN.String(), ctx, data)
}

func IsTokenExpired(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == UnauthorizedError_TOKEN_EXPIRED.String() && e.Code == 401
}

func ErrorTokenExpired() *errors.Error {
	return errors.New(401, UnauthorizedError_TOKEN_EXPIRED.String(), "")
}

func ErrorTokenExpiredWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(401, UnauthorizedError_TOKEN_EXPIRED.String(), ctx, data)
}

func IsInternalServerError(err error) bool {
	if err == nil {
		return false
	}
	e := errors.FromError(err)
	return e.Reason == ServerError_INTERNAL_SERVER_ERROR.String() && e.Code == 500
}

func ErrorInternalServerError() *errors.Error {
	return errors.New(500, ServerError_INTERNAL_SERVER_ERROR.String(), "")
}

func ErrorInternalServerErrorWithContext(ctx context.Context, data map[string]any) *errors.Error {
	return errors.NewWithContext(500, ServerError_INTERNAL_SERVER_ERROR.String(), ctx, data)
}
